---
title: 第3章 栈和队列
author: Allwayso
update: 2025-12-29
status: Updating
---

### 栈的定义

栈是一种只能在同一端进行插入或删除操作的线性表

**栈的逻辑特点**

1. 后进先出（LIFO），即最后进栈的元素最先出栈
2. 栈顶（Top）是允许进行插入和删除的一端，栈底（Bottom）是固定的一端
3. 进栈（Push）使新元素成为新栈顶，出栈（Pop）删除当前栈顶元素

---

### 栈的存储结构

**顺序栈**

1. 采用数组存储元素，利用整型变量 top 指向栈顶元素
2. 栈空条件：top == -1
3. 栈满条件：top == MaxSize - 1
4. 算法名称：初始化栈、销毁栈、进栈、出栈、取栈顶元素

**链栈**

1. 采用单链表实现，通常使用带头结点的单链表
2. 栈顶设在链表的头部（头结点之后），方便插入和删除
3. 不存在栈满溢出问题，适合元素变化范围大的场景
4. 算法名称：初始化链栈、进链栈、出链栈、取链栈顶元素

---

### 队列的定义

队列是一种只能在不同端进行插入或删除操作的线性表

**队列的逻辑特点**

1. 先进先出（FIFO），最先入队的元素最先出队
2. 队尾（Rear）进行插入操作，队头（Front）进行删除操作
3. 每次进队元素成为新队尾，每次出队只能删除当前队头元素

---

### 队列的存储结构

**顺序队与循环队列**

1. 顺序队通过 front 和 rear 管理，直接使用数组会产生假溢出
2. 循环队列将存储空间逻辑上构造成环状，利用取模运算实现指针循环
3. 队空条件：front == rear
4. 队满条件：(rear + 1) % MaxSize == front
5. 算法名称：循环队列进队、循环队列出队、初始化队列

**链队**

1. 采用单链表实现，包含头结点，并维护 front 和 rear 两个指针
2. 队空条件：front->next == NULL 或 front == rear
3. 算法名称：链队进队、链队出队、初始化链队

---

### STL中的栈与队列

**栈容器 stack**

1. stack 是容器适配器，默认基于 deque 实现
2. 常用成员函数：empty()、size()、top()、push()、pop()

**队列容器 queue**

1. queue 是先进先出适配器
2. 常用成员函数：empty()、size()、front()、back()、push()、pop()

**双端队列 deque**

1. 支持在两端高效插入和删除的序列容器
2. 算法名称：push_front、push_back、pop_front、pop_back

**优先队列 priority_queue**

1. 元素按优先级出队，默认大根堆（最大元素先出）
2. 算法名称：大根堆定义、小根堆定义

---

### 栈和队列的扩展应用

**单调栈**

1. 栈内元素从栈底到栈顶始终保持单调递增或单调递减
2. 进栈规则：若新元素破坏单调性，先弹出栈顶元素直到满足要求再进栈
3. 算法名称：产生单调栈算法、利用辅助栈改变栈单调性算法

**单调队列**

1. 队列内元素从队头到队尾保持单调性
2. 常用于解决滑动窗口最值问题
3. 算法名称：求滑动窗口最大值算法

---

### 栈和队列的综合应用

**栈的应用名称**

1. 括号匹配算法
2. 中缀表达式转后缀表达式算法
3. 后缀表达式求值算法
4. 迷宫路径算法（深度优先搜索 DFS）

**队列的应用名称**

1. 迷宫最短路径算法（广度优先搜索 BFS）
2. 报数问题算法

---

### 题目索引

模拟栈`stackModel.h`，模拟队列`queueModel.h`,以下题目除了滑动窗口都是用模拟栈/队列实现的

1. **括号配对检测**：利用 `Stack<char>` 检查字符串中 `()[]{}` 是否正确闭合与嵌套
   
   `BracketMatching.cpp`

2. **后缀表达式（逆波兰表达式）求值**：利用 `Stack<int>` 计算以空格分隔的算术表达式，支持多位数运算
   
   `PostfixEvaluation.cpp`

3. **中缀表达式转后缀表达式**：利用栈处理运算符优先级，将标准数学表达式转换为机器易读的后缀形式
   
   `InfixToPostfix.cpp`

4. **中缀表达式求值**：中缀转后缀+后缀求值 `InfixEvaluation.cpp`

5. **迷宫路径查找（DFS）**：利用栈记录路径，探索从起点到终点的可行通路

6. **迷宫最短路径查找（BFS）**：利用队列层层扩展，寻找连接起止点的最短步骤。
   
   > 5.6题都属于图论内容，所以dfs和bfs将在第八章图中实现；而且迷宫路径dfs不太适合栈，更适合递归一点

7. **滑动窗口最大值**：利用单调队列(两个双端队列)维护窗口内的最值，实现 O(n) 时间复杂度的求解`SlidingWindow.cpp`

8. **报数/约瑟夫环问题**：利用循环队列模拟人员出列过程。`JosephRing.cpp`

9. **优先队列**：虽然优先队列并不是队列，也不是用队列实现，但是既然ppt中出现了就实现一下吧

`PriorityQueue.h`

---

### 自由练习

1. 利用顺序栈倒置循环队列：push再pop就行

2. 链栈删除第k个结点：链栈就是头插法实现的链表，等于链表删除倒数第k个结点

3. 列车编组：对于奇数输入，in完直接out；对于偶数输入，先in；等所有输入完成，全部out

4. **用队列推杨辉三角**：当前队列存当前行，在输出的同时推下一行`YHTriangle.cpp`

5. **进制转换**：取余入队后取商，注意一下16进制的输出即可`BaseConversion.cpp`

6. 判断合法字符串：双指针就行；前半段入栈，逐个比较后半段与栈顶(希冀中第九个测试数据有误)

7. 偶数移到奇数前（保留顺序）：又是这种莫名其妙的题，遇到偶数输出，奇数入队即可
